import os
import warnings
from snakemake.utils import min_version

min_version("5.18.0")

configfile: "config.yaml"

if not config["is_paired"]:
    read_pair_tags = ["R1"]

else:
    read_pair_tags = ["R1", "R2"]

sample_name = config["sample_name"]
taxonomic_level = config["organism_taxonomic_level"].capitalize()

tools = []
if config["use_kraken"]:
    tools.append("kraken")
if config["use_centrifuger"]:
    tools.append("centrifuger")

wildcard_constraints:
    sample = "|".join(sample_name),
    tool = "|".join(tools),
    read_pair_tag = "R1|R2",
    taxlvl = "G|S|F|O|C|P|K"

if config["long_reads"] and config["is_paired"]:
    raise ValueError("Long reads are enabled but the reads are paired. Long reads typically refer to single-end reads, such as those generated by PacBio or Oxford Nanopore technologies. Please set 'is_paired' to False for long reads.")


if config["trim_adapters"] and not config["trimmomatic_qc_trim_reads"]:
    warnings.warn("Adapter trimming is enabled but Trimmomatic is not selected as the trimming tool. Please ensure that the selected tool supports adapter trimming. Overrriding the quality_control to True.")
    config["trimmomatic_qc_trim_reads"] = True

def all_input(wildcard):
    input_dict = {}

    input_dict["raw_qc_report"] = "qc_reports/raw_multiqc_report.html"
    if config["analysis_type"] == "full":
        input_dict["processed_qc_report"] = "qc_reports/processed_multiqc_report.html"

        if config["use_kraken"]:
          input_dict["krona_graph_krak"] = expand("results/kraken/{sample}_krona_graph.html", sample=sample_name)
          input_dict["otu_table_k"] = expand("results/kraken/otu_table_{taxlvl}.csv", taxlvl=taxonomic_level)
          input_dict["kraken_report"] = expand("results/kraken/{sample}_kraken2_report.txt", sample=sample_name)
          input_dict["kraken_rarefaction"] = expand("results/kraken/{sample}_rarefaction.jpg", sample=sample_name)
          input_dict["braken_report_k"] = expand("results/kraken/{sample}_kraken2_report_bracken.txt", sample = sample_name)

        if config["use_centrifuger"]:
            input_dict["krona_graph_cent"] = expand("results/centrifuger/{sample}_krona_graph.html", sample=sample_name)
            input_dict["cent_report"] = expand("results/centrifuger/{sample}_centrifuger.tsv", sample=sample_name)
            input_dict["otu_table_c"] = expand("results/centrifuger/otu_table_{taxlvl}.csv", taxlvl=taxonomic_level)
            input_dict["centrifuger_rarefaction"] = expand("results/centrifuger/{sample}_rarefaction.jpg", sample = sample_name)
            input_dict["braken_report_c"] = expand("results/centrifuger/{sample}_kraken2_report_bracken.txt", sample = sample_name)

        if config["use_emu"] and config["long_reads"]:
            input_dict["emu_report"] = expand("results/emu/{sample}_rel-abundance.tsv", sample = sample_name)
            input_dict["emu_phyloseq"] = "results/emu/emu_phyloseq.rds"
        elif config["use_emu"] and not config["long_reads"]:
            raise ValueError("In the current pipeline EMU is applied only to long-reads, if you're using short reads 'use_emu' MUST be set to False in the config.yaml")

        if config["use_dada2"] and config["is_paired"] and not config["long_reads"]:
            input_dict["dada2_report"] = "results/dada2/summary.tsv"
        elif config["use_dada2"] and not config["is_paired"]:
            raise ValueError("DADA2 is enabled but the reads are not paired. DADA2 typically requires paired-end reads for optimal performance.")
        elif config["use_dada2"] and config["long_reads"]:
            raise ValueError("DADA2 is enabled but the reads are long. DADA2 typically requires short reads (amplicon-derived) for optimal performance.")
    return input_dict

rule all:
    input:
        unpack(all_input)

include: "rules/quality_control.smk"
include: "rules/preprocessing.smk"
include: "rules/long_reads.smk"
include: "rules/short_reads.smk"
include: "rules/postprocessing.smk"